# 인덱스 기본 개념, 실전 활용법

### 인덱스
- 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료 구조
- 직관적으로는 데이터를 빨리 찾기 위해 특정 칼럼을 기준으로 미리 정렬해 놓으 표 라고 표현할 수 있다.

### 기본키(primary key, pk)
- 테이블 내 각 행을 고유하게 식별하기 위해 사용되는 열 또는 열의 집합
- unique, not null
- 기본 키로 설정된 열은 자동으로 클러스터링 인덱스가 생성 된다

### 클러스터링 인덱스
- 테이블의 데이터가 인덱스 키 값에 따라 물리적으로 정렬되어 저장되는 방식
- 따라서 클러스터링 인덱스가 있는 테이블에서는 데이터 자체가 인덱스의 일부로 사용 된다.
- 특징:
  - 테이블당 **하나의 클러스터링 인덱스**만 생성 가능(데이터는 한 가지 순서로만 정렬될 수 있기 때문).
  - 일반적으로 Primary Key가 클러스터링 인덱스로 설정됨.
    - PK가 없을 땐 유니크 키
    - 둘다 없을 경우 6byte의 Hidden Key를 생성
  - 리프 노드(Leaf Node)에 실제 데이터가 저장되며, 데이터와 인덱스가 같은 구조를 공유함.
  - 데이터 검색 속도가 빠름(특히 범위 검색에 유리).
  - InnoDB 스토리지 엔진에서 기본적으로 Primary Key는 클러스터링 인덱스로 설정됨.
- 장점
  - 데이터가 정렬된 상태로 저장되므로 범위 쿼리나 정렬 작업에서 높은 성능을 발휘.
  - 리프 노드에 실제 데이터가 포함되어 있어 추가적인 참조 과정이 필요 없음.
- 단점
  - 삽입, 삭제, 업데이트 시 데이터 재배열이 필요할 수 있어 성능 저하 가능.
  - 테이블당 하나만 생성 가능.

### 넌 클러스터링 인덱스
- 데이터와 별도로 저장된 인덱스로, 인덱스는 특정 컬럼 값과 해당 데이터의 위치를 가리키는 포인터를 포함.
- 데이터 자체는 정렬되지 않는다.
- 특징:
  - 테이블당 여러 개의 넌 클러스터링 인덱스를 생성할 수 있음.
  - 리프 노드에는 실제 데이터 대신 데이터의 위치(Row Locator 또는 Primary Key)가 저장됨.
  - 데이터를 찾기 위해서는 두 번의 조회 과정이 필요: 먼저 인덱스를 검색한 뒤 해당 위치로 이동하여 데이터를 가져옴.
- 장점:
  - 여러 개 생성 가능하므로 다양한 쿼리에 대해 최적화 가능.
  - 삽입, 삭제, 업데이트 작업 시 물리적 데이터 정렬이 필요 없으므로 성능 저하가 적음. (클러스터링 인덱스와 비교 했을 때)
- 단점:
  - 추가적인 디스크 공간이 필요하며, 검색 시 I/O 작업이 더 많이 발생할 수 있음.
    - 인덱스 조건에 부합한 where 조건이 있더라도 select에 인덱스에 포함된 컬럼 외에 다른 컬럼값이 필요할때는 Non Clustered Key에 있는 Clustered Key 값으로 데이터 블록을 찾는 과정이 필요.

### UNIQUE
- MySQL은 UNIQUE 제약 조건을 추가하면 자동으로 인덱스가 생성된다 (넌 클러스터링)
- 한 테이블에 여러 개 설정 가능.
- NULL 값을 허용(단, MySQL에서는 여러 개의 NULL 값도 서로 다른 값으로 간주).

### 인덱스는 항상 옳은가? 무분별한 인덱스 생성시
- 쓰기 작업 성능 저하
- 저장 공간 증가 (각 인덱스는 별도의 저장 공간을 차지함. 특히 넌 클러스터링 인덱스는 테이블 데이터와 별도로 저장되므로 디스크 공간이 추가적으로 필요)
- 쿼리 최적화 혼란
  - 옵티마이저가 비효율 적인 실행 계획을 선택할 가능성이 높아짐
- 리소스 낭비, 읽기 성능 저하
  - 불필요한 인덱스 관리에 더 많은 리소스를 소비하게 만들어 읽기 성능에도 악영향을 미칠 수 있음

### 멀티 컬럼 인덱스
 - 여러 열을 결합하여 하나의 인덱스 생성
```
CREATE INDEX idx_users ON users (부서, 이름);
--- 부서와 나이를 결합한 단일 인덱스 생성
```
- 첫 번째 열(부서)을 기준으로 데이터를 정렬하고, 그 값이 동일한 경우 두 번째 열(이름)을 기준으로 정렬하는 방식으로 동작
- 최대 16개의 컬럼 사용 가능

![image](https://github.com/user-attachments/assets/a0c6a28f-f2e2-45db-8ad6-ba3b7f9f5fac)

- 부서를 기준으로 먼저 정렬이 되어 있고, 그 다음 같은 부서 내에서 이름을 기준으로 정렬. 
- 부서 컬럼만 놓고 봤을 때는 부서 인덱스와 동일한 정렬 상태를 갖고 있다.
- 따라서 위의 멀티 컬럼 인덱스의 구조를 활용하면 부서 컬럼만을 활용한 인덱스처럼 쓸 수도 있다.
  - 이 상태에서 부서 컬럼의 인덱스를 따로 만들 필요가 없다는 의미
  - 이름의 경우에는 이름 컬럼만을 활용한 인덱스처럼 사용 불가
- 처음에 배치된 컬럼만 가능

#### 멀티 컬럼 인덱스 구성 순서 팁
- 대기업에서 `회계 부서`의 `박미나`를 찾아야 한다고 가정하자.
- `회계 부서`의 모든 인원을 만나본 뒤에 `박미나`를 찾는게 빠를까? 아니면 `박미나`라는 이름을 가진 동명이인 사람들한테 직접 찾아가서 `회계 부서`인지를 물어보는 게 빠를까?
- 일반적으로 `회계 부서`의 인원보다 `박미나`라는 이름을 가진 인원이 훨씬 적기 때문에, `박미나`를 먼저 찾은 뒤에 `회계 부서`인지를 물어보는게 빠를 것이다.
- 이를 일반화해서 표현하자면 ‘**소분류를 먼저 탐색한 뒤, 대분류를 탐색하는 게 빠르다.**’라고 할 수 있다. 컴퓨터도 이 특성이 동일하게 적용된다.
- **데이터 중복도가 낮은 칼럼이 앞쪽으로 오는 것이 좋은 경우가 많다**
  - 절대적인 법칙은 아니다

### 커버링 인덱스
- MySQL의 경우 인덱스안에 포함된 데이터를 사용할 수 있으므로 이를 잘 활용한다면 실제 데이터까지 접근할 필요가 전혀 없다.
- 쿼리를 충족시키는 데 필요한 모든 데이터를 갖고 있는 인덱스를 커버링 인덱스 (Covering Index 혹은 Covered Index) 라고합니다.
  - SELECT, WHERE, ORDER BY, GROUP BY 등에 사용되는 모든 컬럼이 인덱스의 구성요소인 경우를 얘기
