### 함수 종속성
- 테이블 내 특정 컬럼(결정자)의 값이 다른 컬럼(종속자)의 값을 유일하게 결정하는 관계
- X -> Y$와 같이 표기하며, "X가 Y를 함수적으로 결정한다"라고 읽음
  - 결정자 : 다른 컬럼의 값을 결정하는 컬럼 (X)
  - 종속자 : 값이 다른 컬럼에 의해 결정되는 컬럼 (Y)
- 정규화는 잘못된 함수 종속 관계를 분석하고, 테이블을 분리하여 올바른 종속 관계로 만들어가는 과정

### 정규형(Normal Form) 단계
정규화는 여러 단계를 거치며, 각 단계를 '정규형'이라고 부른다

#### 제1 정규형 (1NF)
- 테이블의 모든 컬럼(애트리뷰트)이 **원자적(Atomic)인 값**만을 가져야 한다는 규칙
- 하나의 컬럼에 여러 정보를 쉼표 등으로 섞어 저장하는 방식을 방지하는 것이를 통해 데이터 검색, 수정, 타입 활용의 어려움을 해결[
- 반복되는 정보를 별도의 행(튜플)으로 분리하여 각 컬럼이 원자성을 만족하도록 테이블을 수정

#### 제2 정규형 (2NF)
- 제1 정규형을 만족하고, 테이블의 모든 컬럼이 기본 키에 대해 **완전 함수 종속(Fully Functional Dependent)**이어야 한다는 규칙
- 부분 함수 종속(Partial Functional Dependency)의 제거
  - 이는 복합 기본 키의 일부에만 특정 컬럼이 종속되는 경우를 의미
- 부분 함수 종속 관계가 발견되면, 해당 종속 관계에 맞게 테이블을 분리하여 해결

#### 제3 정규형 (3NF)
- 제2 정규형을 만족하고, **이행적 함수 종속(Transitive Functional Dependency)**이 없어야 한다는 규칙
- 기본 키가 아닌 컬럼이 다른 컬럼을 결정하는 관계(PK -> 일반컬럼1 -> 일반컬럼2)를 제거
- 이행적 종속 관계에 있는 결정자와 종속자를 묶어 별도의 테이블로 분리
---

#### BCNF (Boyce-Codd Normal Form)
- 제3 정규형을 강화한 버전으로, 테이블의 **모든 결정자가 후보 키(Candidate Key)여야 한다**는 규칙
- 제3 정규형을 만족하더라도 드물게 발생하는 데이터 이상 현상을 해결하는 것
  - 이는 후보 키가 아닌 컬럼이 다른 컬럼을 결정하는 복잡한 종속 관계에서 발생
  - BCNF 위반 -> 비즈니스 규칙에 의해 주로 발생 (한 교수는 오직 하나의 특강만 담당한다)
- 문제가 되는 함수 종속성(결정자가 후보 키가 아닌 경우)을 기준으로 테이블을 분리하여 해결

### 실무와 정규화
- 실무에서는 보통 제3 정규형 또는 BCNF까지 정규화를 진행하는 것을 목표
- 이론과 실제로 쓰이는 방식
  - 상식적이고 합리적으로 데이터를 정리하려는 노력은 자연스럽게 정규화된 형태로 귀결되는 경우가 많음
  - 정규화 이론은 보통 자신의 직관적인 설계가 논리적으로 탄탄한지 검증하는 단계에서 쓰임

### 역정규화 (Denormalization)
- 역정규화는 조회 성능 향상을 위해 의도적으로 정규화 원칙을 위배하여 데이터 중복을 허용하는 프로세스입니다
- 잦은 JOIN으로 인해 발생하는 성능 저하를 해결하기 위한 기법입니다
- 데이터의 정합성과 쓰기(Write) 성능을 일부 희생하여 읽기(Read) 성능을 얻는 전략적 선택
- 주요 기법
  - 중복 컬럼 추가 : JOIN을 줄이기 위해 다른 테이블의 컬럼을 복사해 오는 가장 흔한 기법
  - 파생 컬럼 추가 : 조회 시점에 필요한 계산(SUM, COUNT 등) 결과를 미리 컬럼에 저장해두는 방식
  - 테이블 통합 : 1:1 관계처럼 항상 함께 조회되는 테이블을 하나로 합쳐 JOIN을 원천적으로 제거
- 적용 원칙
  - 역정규화는 '선 정규화, 후 역정규화'원칙을 반드시 지키자
  - 추측이 아닌 실제 성능 테스트를 통해 병목 지점을 확인한 후, 최후의 수단으로 신중하게 적용
- 때로는 역정규화처럼 보이는 설계가 사실은 비즈니스 요구사항을 만족시키는 경우도 있다 (중복 칼럼 추가)
  - 예를 들어, 고객의 주문 내역은 주문이 일어난 시점의 상품명과 가격을 그대로 보존해야 하는 역사적 데이터(스냅샷)가 된다
  - 따라서 order_item 테이블에 product_name과 order_price를 저장하는 것은 데이터 불일치 문제가 아니라, 오히려 비즈니스 규칙을 정확히 만족시키는 설계
