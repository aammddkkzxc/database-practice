### 키(Key)의 종류와 중요성
- 키는 테이블의 각 행(Row)을 **고유하게 식별**, 테이블 간의 **관계를 연결**, 데이터의 **무결성을 보장**하는 핵심 장치
- 기본키 -> 변경될 시 미치는 영향이 엄청나다. 재앙 초래

#### 키와 종류
- 기본 키 (Primary Key - PK)
  - 테이블의 모든 행을 유일하게 식별하는 대표 키입니다
  - NOT NULL, UNIQUE, 실무에서 값이 절대 변하지 않아야 한다
- 후보 키 (Candidate Key)
  - 기본 키가 될 수 있는 모든 키를 말하며, **유일성**과 **최소성**을 모두 만족
  - 유일성 : 모든 행을 서로 구분
  - 최소성 : 행을 식별하는 데 꼭 필요한 최소한의 컬럼만으로 구성
- 대체 키 (Alternate Key)
  - 후보 키 중에서 기본 키로 선택되지 않은 나머지 키들
- 외래 키 (Foreign Key - FK)
  - 한 테이블의 컬럼이 다른 테이블의 기본 키를 참조하여 테이블 간의 관계를 연결
- 복합 키 (Composite Key)
  - 두 개 이상의 컬럼을 묶어서 하나의 키로 사용하는 것

### 자연 키(Natural Key) vs 대리 키(Surrogate Key)
- 기본 키를 선택할 때 비즈니스 의미를 가진 **자연 키**와 비즈니스와 무관한 **대리 키** 사용에서의 고민
- 자연키 
  - 치명적 단점
    - 변경 가능성 
    - 실무에서 기본 키는 절대 변하면 안 된다는 불변성 원칙을 지키기 어렵다 
  - 자연 키가 변경되면 
    - 참조 무결성 제약조건 위반
    - 모든 자식 테이블의 데이터를 수정해야 하는 연쇄 업데이트 발생
    - 과거 데이터의 역사성 훼손
    - 외부 시스템과의 연동 문제 등 심각한 재앙
- 대리 키의 존재 이유는 단 하나, 절대 변하지 않는다
  -  AUTO_INCREMENT, or UUID

#### 현대적 설계의 표준 : 대리 키-PK, 자연 키-UNIQUE
- 대리 키를 PK로 사용 : 관계의 안정성을 확보
- 자연 키에 UNIQUE 제약조건 적용 : 비즈니스 데이터의 고유성을 보장
- 비즈니스 요구사항의 폭발적인 변화 속도에 영향 받지 않는 대리 키가 매우 효과적
- 현대적 설계의 핵심은 **느슨한 결합**

#### 과거에는 왜?
- 직관성 : 그 값만 봐도 어떤 데이터인지 바로 알 수 있음
- 저장 공간 효율 : 과거에는 디스크 비용이 비쌌다. 별도의 ID 컬럼을 추가할 필요가 없었음
- 데이터 모델링 순수주의 : 비즈니스적으로 의미 있는 키를 써야 한다는 모델링 원칙이 있었음
- 과거의 설계는 데이터의 의미와 직관성을 중시

### 복합 키(Composite Key) 설계
- 두 개 이상의 컬럼을 묶어 하나의 기본 키(PK)로 사용하는 복합 키는 전통적인 모델링에서 자연 키를 표현하는 방법이었다
- 문제점 : 자연 키의 단점을 그대로 가진다.
- 결론 : 대리 키를 PK로 사용, **비즈니스적 유일성이 필요한 컬럼 조합에는 복합 UNIQUE 제약조건**을 설정

### 다대다(N:M) 관계와 키
- 중간에 연결 테이블을 만들어 두 개의 일대다(1:N) 관계로 해소(예: orders 와 products 테이블 사이에 order_item 테이블)
- 대리 키 기본 키(PK)로 만들고, 두 외래 키의 조합(order_id, product_id)에는 **복합 UNIQUE 제약조건**을 설정