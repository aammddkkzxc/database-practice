## 조회와 정렬
- 별칭
  - 가독성 향상, join시 열 이름 충돌 방지
- 실무 팁 (컨벤션)
  - 테이블에 별칭으로 사용하는 AS는 주로 생략 
  - 컬럼에 별칭으로 사용하는 AS는 가독성을 위해 생략하지 않고 사용

### 조건 연산자
- 여러 조건들을 조합하는 논리 연산자 : AND, OR, NOT 
  - 매번 = 이나 > 같은 기본 연산자/논리 연산자 조합해서 사용하면 쿼리가 길어지고 비효율적
  - 편리한 조건 검색 : BETWEEN, IN, LIKE, IS NULL 사용해서 커리 줄이자
  ```
    SELECT * FROM products WHERE price < 5000 OR price > 15000;
    SELECT * FROM products WHERE price NOT BETWEEN 5000 AND 15000
  ```
  ```
    SELECT * FROM products WHERE name = '갤럭시' OR name = '아이폰' OR name = '에어팟';
    SELECT * FROM products WHERE name IN ('갤럭시', '아이폰', '에어팟');
  ```
  ```
    SELECT * FROM customers WHERE email LIKE 'sejong%';
  ```
- 날짜 -> 문자열 비교 (비효율 발생) 혹은 BETWEEN (00:00:00 기준으로 됨) 쓰지 말자
 
### 정렬
- SELECT 와 WHERE 만 사용해서 데이터를 조회하면 순서 데이터베이스 마음대로 조회된다
- ORDER BY 정렬기준열 정렬방식
  - SELECT문 마지막에 위치
  - 정렬방식 생략 시 오름차순
  - 콤마(,)로 정렬 기준열 추가 가능

### LIMIT
- 조회 되는 건수가 엄청나게 많을 경우 문제
- 결과 개수 제한, 페이징
- LIMIT 는 ORDER BY 뒤에 위치
  - 반드시 먼저 ORDER BY로 의미있는 순서로 정렬을 시키고 사용해야 한다
  - LIMIT 건너뛸개수, 가져올개수

### DISTINCT
- 실무에서 DISTINCT 는 데이터를 탐색하고 분석할 때 많이 사용
- "우리 서비스에는 어떤 종류의 고객들이 있지?", "판매된 상품의 카테고리는 총 몇 가지지?" 와 같이 데이터의 '종류'를 파악할 때 아주 유용
- DISTINCT 는 결과를 보여주기 전에 내부적으로 중복을 제거하기 위한 과정을 거쳐야 한다
  - 데이터가 아주 많은 경우 일반적인 SELECT 보다 성능이 저하될 수 있다. 대량의 데이터라면 성능을 확인할 필요가 있다
  - 여러 컬럼에도 적용 된다
  ```
    SELECT DISTINCT customer_id, product_id FROM orders;
  ```

### NULL
- '빈 상자'가 아니라 '상자가 있는지조차 모른다'는 표시
- NULL 은 특정 값이 아니기 때문에 등호( = )로 비교할 수 없다
  - 어떤 값 = NULL 이라는 비교 연산은 항상 '알 수 없음(UNKNOWN)'이라는 결과를 반환
- IS NULL / IS NOT NULL 사용하자
- MySQL의 NULL 정렬 규칙
  - MySQL은 NULL 을 가장 작은 값으로 취급한다