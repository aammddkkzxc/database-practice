### 인덱스
- 데이터양이 많아질수록 인덱스 없는 검색은 풀 테이블 스캔(Full Table Scan)으로 인해 매우 느려진다
  - 데이터 양에 비례하여 성능이 저하
- WHERE 절에 자주 사용되는 컬럼에 인덱스를 생성하는 것이 기본적인 해결책
- 인덱스의 핵심은 데이터가 항상 정렬된 상태로 유지된다는 점 (트리 구조 사용,  특히 B-Tree)
- 트리의 한쪽으로 치우치는 문제를 해결한 벨런스 트리(Balanced Tree)를 사용하여 최악의 경우에도 O(log n) 성능을 보장
- 인덱스를 사용하면 탐색해야 할 행(rows)의 수가 극적으로 줄어들어 검색 성능이 크게 향상

#### 인덱스 생성, 조회, 삭제
- MySQL에서는 PRIMARY KEY, FOREIGN KEY, UNIQUE 제약조건을 설정하면 해당 컬럼에 인덱스가 자동 으로 생성
- EXPLAIN 명령어 -> 데이터베이스의 실행 계획을 확인, 이를 통해 인덱스 사용 여부를 반드시 점검
- 실행 계획의 type 이 ALL 이면 풀 테이블 스캔, ref 나 range 이면 인덱스 사용을 의미

#### 인덱스와 비교
- 동등 비교( = ) 조건에 인덱스가 사용될 때, 실행 계획의 type 은 ref 로 표시
  - 데이터를 매우 효율적으로 참조했다는 의미
- 인덱스와 범위 검색 BETWEEN , > , < 와 같은 범위 검색에 인덱스가 사용될 때, 실행 계획의 type 은 range 로 표시
  - 데이터베이스는 정렬된 인덱스에서 범위의 시작점을 빠르게 찾고, 범위가 끝날 때까지만 순차적으로 스캔하므로 효율적
  - 인덱스를 사용하면 결과가 인덱스 키 순서로 정렬되어 나올 수 있지만, 정확한 정렬을 위해서는 ORDER BY 를 명시

#### 인덱스와 LIKE 범위 검색
- LIKE 검색에서 인덱스를 활용하려면 와일드카드( % )가 반드시 검색어의 뒤쪽에 위치해야 한다 LIKE '검색어%' 
- 와일드카드가 검색어의 앞에 오면 ( LIKE '%검색어' ) 시작점을 특정할 수 없어 인덱스를 사용하지 못하고 풀 테이블 스캔이 발생
- 텍스트 중간에 포함된 단어를 검색하기 위해서는 LIKE 대신 전문 검색(Full-Text Search) 기능을 사용해야 한다
  - 텍스트를 단어(토큰) 단위로 쪼개서 인덱싱하는 방식
  - 쇼핑몰에서 상품명 검색 기능을 구현해야 한다면, LIKE 대신 MATCH ... AGAINST 구문을 사용하는 전문 검색 기능을 도입하는 것이 해결 방법

#### 인덱스와 정렬
- 정렬( RDER BY)은 비용이 많이 드는 작업이지만, 인덱스를 활용하면 별도의 정렬 과정(filesort)을 생략하여 성능을 개선
- WHERE 조건과 ORDER BY 조건이 인덱스와 일치하면, 데이터베이스는 이미 정렬된 인덱스를 순서대로 읽기만 하므로 filesort 가 발생하지 않는다
- 정렬이 반대일 때는 인덱스를 거꾸로 읽는 역방향 스캔(Backward index scan)을 통해 filesort 를 피할 수 있다
- 쿼리의 정렬 순서와 일치하는 내림차순 인덱스를 생성하면 가장 이상적인 정렬 최적화가 가능

### 인덱스와 성능

#### 인덱스 손익분기점
- 옵티마이저는 인덱스를 사용하는 것이 오히려 비효율적이라고 판단하면, 테이블 전체를 스캔(Full Table Scan)하는 방법을 선택
- 인덱스를 사용하는 비용 : 인덱스 탐색 비용 + 인덱스에서 찾은 주소로 테이블에 접근하는 비용 (랜덤 I/O)
- 풀 테이블 스캔 비용 : 테이블 전체를 순차적으로 읽는 비용 (순차 I/O)
- 일반적으로 전체 데이터의 약 20~25% 이상을 조회해야 하는 쿼리는 인덱스를 통해 테이블의 각 행에 개별적으로 접근 하는 것보다, 차라리 테이블 전체를 순차적으로 스캔하는 것이 더 효율적이라고 알려져 있다

#### 순차,랜덤 I/O
- 순차 I/O (Sequential I/O)
  - 데이터가 저장된 위치를 한 번 찾으면, 그 이후로는 순서대로 쭉 읽기만 하면 된다
  - HDD의 경우 디스크의 헤드가 거의 움직이지 않고 연속된 데이터를 읽어오므로 작업이 매우 빠르고 효율적 
  - SSD의 경우 "여기서부터 100개 읽어와" 라는 하나의 큰 명령으로 처리할 수 있다
- 랜덤 I/O (Random I/O)
  - HDD의 경우 읽어야 할 데이터가 디스크의 여러 곳에 흩어져 있어, 디스크 헤드가 물리적으로 해당 위치까지 이동해야 한다
    - 데이터의 위치를 찾는 데 걸리는 시간(탐색 시간, Seek Time)이 추가
  - SSD의 경우 찾아야 하는 데이터가 100개라면 100개의 작은 명령을 각각 처리
    - 작은 명령을 여러 번 처리하는 것은 SSD 컨트롤러에 더 많은 오버헤드(부하)를 준다

#### 커버링 인덱스
- 옵티마이저가 인덱스를 사용하기로 결정해도, 추가적인 작업이 필요했다
  - 인덱스 스캔
  - 테이블 데이터 접근
  - **Extra : Using index condition**
- 커버링 인덱스는 쿼리에 필요한 모든 컬럼을 포함하고 있는 인덱스 -> 추가적인 작업 필요 없음
  - **Extra : Using index** 로 확인
- 압도적인 SELECT 성능 향상, 특히 COUNT 쿼리 최적화
- 저장 공간 증가, 쓰기 성능 저하

#### 복합 인덱스
- 두 개 이상의 컬럼을 묶어서 하나의 인덱스로
- 인덱스의 칼럼 순서대로 사용하자
  - (A, B, C) 순서로 생성되었을 때, WHERE 절에서 A 조건 없이는 B나 C를 사용할 수 없다
  - 왼쪽의 기준 없이는 오른쪽 칼럼이 정렬되었다고 볼 수 없기 때문
- 등호(=) 조건은 앞으로, 범위 조건(<, >)은 뒤로
  - 범위 조건( > , < , BETWEEN , LIKE %... )이 사용되는 순간, 그 뒤에 오는 컬럼은 인덱스의 정렬 효과를 누릴 수 없음
  - 변별력이 높은 등호( = ) 조건으로 사용할 컬럼을 인덱스 앞쪽에 배치
  - 여러 조건을 사용하고 싶다면 **IN 절**사용. 여러 개의 등호 조건으로 취급되기 때문
- 정렬(ORDER BY)도 인덱스 순서에 맞게 쓰자
  - 결과를 가져온 뒤 별도의 정렬 과정을 없게 할 수록 좋다

#### 인덱스 설계 가이드 라인
- 핵심 규칙 : 인덱스는 카디널리티가 높은, 즉 식별력이 좋은 컬럼에 생성할 때 가장 효율적
- WHERE 절에서 자주 사용되는 컬럼
- JOIN 의 연결고리가 되는 컬럼 (외래 키)
  - 외래 키 제약조건을 사용하면 자동 생성됨. 종종 외래 키 제약조건을 걸지 않기도 하기 때문에 이 때는 직접 생성시키자
- ORDER BY 절에서 자주 사용되는 컬럼

#### 인덱스 단점과 주의사항
- 저장 공간
  - 인덱스는 원본 테이블과는 별개로, B-Tree 구조를 가진 물리적인 파일로 디스크에 저장된다. 추가 저장 공간이 필요
    - 원본 테이블 크기의 약 10% 내외의 공간을 추가로 차지
- 쓰기 성능 ( INSERT , UPDATE , DELETE )
  - 인덱스의 가장 치명적인 단점이자, 반드시 이해해야 할 핵심 트레이드오프
  - 인덱스에 새로운 데이터에 대한 키값과 주소 추가, B-Tree의 정렬 순서를 유지하고 균형을 맞추기 위한 추가적인 연산이 발생
- 꼭 필요한 인덱스만 만들고, 사용하지 않는 인덱스는 주기적으로 정리하자
- 인덱스 컬럼은 가공하면 안된다
  - 인덱스가 적용된 컬럼을 함수로 감싸거나 계산을 하는 등 가공하게 되면 인덱스가 적용되지 않는다
    - WHERE SUBSTRING(item_name, 1, 5) = '게이밍'
  - **인덱스는 가공되지 않은 원본 값을 기준**으로 만들어지기 때문
  - 칼럼 자체를 가공하기 보다 LIKE 연산자를 사용하는 등 조건을 바꾸자
    - WHERE item_name LIKE '게이밍%'