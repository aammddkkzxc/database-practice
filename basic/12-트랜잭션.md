### 트랜잭션
- 트랜잭션은 START TRANSACTION , COMMIT , ROLLBACK 명령어로 제어
- START TRANSACTION : 트랜잭션의 시작을 데이터베이스에 알린다
- COMMIT : 트랜잭션 내의 모든 작업이 성공했을 때, 변경 사항을 영구적으로 저장
- ROLLBACK : 문제가 발생했을 때, 트랜잭션 내에서 실행한 모든 변경 사항을 취소하고 시작 전 상태로 되돌린다
- MySQL은 기본적으로 autocommit 모드가 활성화되어 있어, 모든 SQL 문이 즉시 커밋되므로 여러 문장을 묶으려면 START TRANSACTION 을 명시적으로 사용

#### ACID 속성
- 원자성 (Atomicity): 트랜잭션은 전부 성공하거나 전부 실패해야 한다 (All or Nothing)
  - 여러 과정을 하나의 작업으로 통합
- 일관성 (Consistency) : 트랜잭션 완료 후에도 데이터베이스는 제약 조건 등 유효한 상태를 유지해야 한다
  - 시스템의 돈의 총량이 바뀌지 않음. 제약 조건 어기지 않음
- 격리성 (Isolation) : 여러 트랜잭션이 동시에 실행될 때, 서로의 작업 중간 결과에 간섭할 수 없다
  - 하나의 트랜잭션이 실행 중일 때, 다른 트랜잭션이 해당 트랜잭션의 중간 결과를 볼 수 없음
- 지속성 (Durability) : 성공적으로 COMMIT 된 트랜잭션의 결과는 시스템 장애가 발생해도 영구적으로 보존된다
  - 데이터베이스의 저장소(SSD, HDD)에 있는 트랜잭션 로그 등에 기록되어, 어떤 장애에도 살아남는다

#### 트랜잭션 격리 수준
- 더티 리드 (Dirty Read)
  - 한 트랜잭션이 아직 COMMIT 하지 않은, 수정 중인 데이터를 다른 트랜잭션이 읽는 것
- 반복 불가능 읽기 (Non-Repeatable Read)
  - 한 트랜잭션 내에서 똑같은 SELECT 쿼리를 두 번 실행했는데, 그 사이에 다른 트랜잭션이 값을 수정하고 COMMIT 하는 바람에 두 쿼리의 결과가 다르게 나오는 현상
  - **같은 행(Row)을 읽는데 값이 달라지는 경우**
- 유령 읽기 (Phantom Read)
  - 한 트랜잭션 내에서 특정 범위의 데이터를 두 번 읽었는데, 첫 번째 조회에서는 없었던 새로운 행이 두 번째 조회에서 나타나는 현상.
  - 다른 트랜잭션이 새로운 행을 INSERT 하고 COMMIT 했기 때문에 발생
  - **같은 조건(where 절)으로 행 집합을 읽는데, 행의 개수가 달라지는 경우**

| 격리 수준          | Dirty Read | Non-Repeatable Read | Phantom Read       |
|-------------------|------------|----------------------|--------------------|
| READ UNCOMMITTED  | 발생       | 발생                 | 발생               |
| READ COMMITTED    | 방지       | 발생                 | 발생               |
| REPEATABLE READ   | 방지       | 방지                 | 발생(일부 방지*)   |
| SERIALIZABLE      | 방지       | 방지                 | 방지               |

- READ UNCOMMITTED : 거의 아무것도 막아주지 않는, 가장 낮은 수준. 정합성 이슈가 많아 거의 사용되지 않는다
- READ COMMITTED : 더티 리드를 방지한다. 즉, COMMIT 된 데이터만 읽을 수 있다. 오라클, SQL Server 등 많은 데이터베이스의 기본 격리 수준
- REPEATABLE READ : 한 트랜잭션 안에서는 데이터의 일관된 조회를 보장해 준다. MySQL의 InnoDB 스토리지 엔진이 사용하는 기본 격리 수준
- SERIALIZABLE : 가장 엄격한 수준. 동시성 문제를 완벽하게 차단하지만, 트랜잭션을 거의 순서대로 실행시켜 동시 처리 성능이 가장 낮다


- MySQL의 InnoDB 엔진은 MVCC와 갭 락(Gap Lock)이라는 기술을 통해 REPEATABLE READ 수준 에서도 대부분의 팬텀 리드가 발생하는 것을 막아준다
- 이 때문에 InnoDB의 REPEATABLE READ는 표준의 SERIALIZABLE에 가까운 격리성을 제공 (완벽한 것은 아니다)
- 특별한 이유가 없다면 MySQL의 기본 격리 수준인 REPEATABLE READ 를 그대로 사용하는 것을 권장

#### 격리 수준 변경
- 현재 세션에서만 변경하기 (가장 일반적)
  - SET SESSION 옵션을 사용하면, 지금 내가 접속한 이 세션에만 격리 수준이 변경
  - 다른 개발자나 사용자에게는 영향을 주지 않으므로 비교적 안전
- 글로벌(전역)으로 변경
  - SET GLOBAL 은 데이터베이스 서버의 기본 격리 수준 자체를 변경
  - 이후에 연결되는 모든 세션에 영향을 준다

#### READ UNCOMMITTED 로 낮추는 것을 고려하는 경우
- 대용량 데이터에 대한 실시간 집계나 통계 작업을 수행시 고민해 볼 수는 있다
- 통계나 분석 작업이 필요하다면, 운영 데이터베이스(Source a.k.a Primary)를 복제한 분석용 데이터베이스(Replica)를 따로 구축, 그곳에서 자유롭게 쿼리를 실행하는 것이 훨씬 더 안전하고 일반적인 방법
- 다음 단계인 READ COMMITTED 와 성능 차이도 거의 나지 않아 거의 사용X

#### SERIALIZABLE 로 높이는 것을 고려하는 경우
- 데이터의 정합성이 극도로 중요해서 아주 작은 예외도 허용할 수 없을 때 사용
- 대부분의 경우, 격리 수준을 무작정 높이기보다는 애플리케이션 코드 레벨에서 SELECT ... FOR UPDATE 와 같은 비관적 락(Pessimistic Lock)을 사용하거나, 버전 번호를 두는 낙관적 락(Optimistic Lock)을 구현
- 이 역시 거의 사용하지 않는다